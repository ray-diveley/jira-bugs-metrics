<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jira Bug Metrics Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .metric-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .metric-card:hover {
            transform: translateY(-5px);
        }
        .metric-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        .metric-unit {
            color: #999;
            font-size: 0.85em;
        }
        .issues-table {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        tr:hover {
            background: #f8f9ff;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }
        .status-done { background: #d4edda; color: #155724; }
        .status-progress { background: #fff3cd; color: #856404; }
        .status-todo { background: #f8d7da; color: #721c24; }
        .priority-row {
            background: #f8f9ff;
            font-size: 0.9em;
        }
        .priority-row td {
            padding-left: 30px;
            border-bottom: 1px solid #e8e9f0;
        }
        .expandable {
            cursor: pointer;
            user-select: none;
        }
        .expandable:hover {
            background: #f0f1ff;
        }
        .expand-icon {
            display: inline-block;
            margin-right: 5px;
            transition: transform 0.2s;
        }
        .expand-icon.expanded {
            transform: rotate(90deg);
        }
        .ticket-link {
            color: #667eea;
            font-weight: bold;
            text-decoration: none;
        }
        .ticket-link:hover {
            color: #5568d3;
            text-decoration: underline;
        }
        .load-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 20px;
            transition: all 0.2s;
        }
        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .timestamp {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.9em;
            opacity: 0.9;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .modal-header {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            color: #666;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.2s;
        }
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }
        .btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5568d3;
        }
        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        .config-btn {
            background: white;
            color: #667eea;
            border: 2px solid white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 10px;
        }
        .config-btn:hover {
            background: #f8f9ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêõ Jira Bug Metrics Dashboard</h1>
        <div class="timestamp" id="timestamp"></div>
        
        <div style="text-align: center; margin-bottom: 20px;">
            <button class="load-btn" onclick="loadLatestMetrics()">üîÑ Refresh Metrics</button>
            <button class="config-btn" onclick="openConfig()">‚öôÔ∏è Configure Dates</button>
            <button class="config-btn" onclick="runMetrics()">‚ñ∂Ô∏è Run Collection</button>
            <button class="load-btn" onclick="location.href='timeline.html'" style="background: #9f7aea;">üïê Timeline</button>
            <button class="load-btn" onclick="location.href='kpi.html'" style="background: #48bb78;">üìä SLA KPIs</button>
            <button class="load-btn" onclick="location.href='trends.html'" style="background: #ed8936;">üìà Trends</button>
        </div>
        
        <div id="error-msg" class="error" style="display:none;"></div>
        
        <!-- Ticket Creation Overview -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h2 style="margin: 0 0 15px 0; font-size: 1.3em;">üìã Ticket Creation Overview</h2>
            <div id="ticket-overview" style="font-size: 1em; line-height: 1.8;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <strong style="font-size: 2em; display: block;" id="overview-total">--</strong>
                        <span style="opacity: 0.9;">Total Tickets</span>
                    </div>
                    <div>
                        <strong style="font-size: 2em; display: block; color: #48bb78;" id="overview-oncall">--</strong>
                        <span style="opacity: 0.9;">During On-Call Hours</span>
                    </div>
                    <div>
                        <strong style="font-size: 2em; display: block; color: #fbd38d;" id="overview-outside">--</strong>
                        <span style="opacity: 0.9;">Outside Coverage</span>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.3);">
                    <div id="overview-breakdown" style="font-size: 0.95em; opacity: 0.95;"></div>
                </div>
            </div>
        </div>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Total Issues</div>
                <div class="metric-value" id="total-count">--</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Avg Open Duration</div>
                <div class="metric-value" id="avg-open">--</div>
                <div class="metric-unit">days</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Avg Resolution Time</div>
                <div class="metric-value" id="avg-resolution">--</div>
                <div class="metric-unit">days</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Avg Comment Response</div>
                <div class="metric-value" id="avg-comment">--</div>
                <div class="metric-unit">days</div>
            </div>
        </div>

        <div class="metrics-grid" style="margin-bottom: 30px;">
            <div class="metric-card" style="border-left: 4px solid #48bb78;">
                <div class="metric-label">On-Call Hours SLA</div>
                <div class="metric-value" id="oncall-sla">--</div>
                <div class="metric-unit" style="font-size: 0.85em;">tickets during coverage</div>
            </div>
            <div class="metric-card" style="border-left: 4px solid #ed8936;">
                <div class="metric-label">After-Hours SLA</div>
                <div class="metric-value" id="afterhours-sla">--</div>
                <div class="metric-unit" style="font-size: 0.85em;">tickets outside coverage</div>
            </div>
            <div class="metric-card" style="border-left: 4px solid #667eea;">
                <div class="metric-label">Overall SLA</div>
                <div class="metric-value" id="overall-sla">--</div>
                <div class="metric-unit" style="font-size: 0.85em;">all tickets</div>
            </div>
        </div>

        <div class="issues-table" style="margin-bottom: 30px;">
            <h2 style="margin-bottom: 10px; color: #333;">
                üìû On-call Performance
                <button onclick="toggleAllOnCallDetails()" style="margin-left: 15px; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                    <span id="toggle-all-icon">‚ñº</span> Expand/Collapse All
                </button>
            </h2>
            <div style="font-size: 1.3em; font-weight: bold; color: #667eea; margin-bottom: 15px;" id="oncall-date-range">
                Loading date range...
            </div>
            <p style="color: #666; font-size: 0.9em; margin-bottom: 15px; font-style: italic;">
                ‚ÑπÔ∏è Tracks who was scheduled on-call vs who actually responded to tickets<br>
                <strong>Schedule Coverage:</strong> Mon-Fri, 7:00 AM - 11:00 PM UTC (started Oct 31, 2025)<br>
                <span style="font-size: 0.85em; color: #999;">Gaps shown as: [Weekend], [After Hours] (11pm-7am UTC), [Before Oct 31]</span>
            </p>
            <table>
                <thead>
                    <tr>
                        <th>On-call Person</th>
                        <th>Tickets During Shifts</th>
                        <th>Responded To</th>
                        <th>Someone Else Handled</th>
                        <th>No Response Yet</th>
                        <th>Compliance Rate</th>
                        <th>Avg Response Time</th>
                    </tr>
                </thead>
                <tbody id="oncall-tbody">
                    <tr><td colspan="7" style="text-align:center; color:#999;">Click "Refresh Metrics" to load data</td></tr>
                </tbody>
            </table>
        </div>

        <div class="issues-table" style="margin-bottom: 30px;">
            <h2 style="margin-bottom: 20px; color: #333;">üë®‚Äçüíª Developer/Assignee Metrics <span id="date-range" style="font-size: 0.7em; color: #666; font-weight: normal;"></span></h2>
            <p style="color: #666; font-size: 0.85em; margin-bottom: 10px; font-style: italic;">
                ‚ÑπÔ∏è "Assignee Response Breached" tracks whether the assignee responded (via comment) or resolved the ticket within SLA <strong>after being assigned</strong> (different from On-Call SLA which tracks initial response when ticket was created)
            </p>
            <table>
                <thead>
                    <tr>
                        <th>Assignee</th>
                        <th>Total Assigned</th>
                        <th>Active (Not Done)</th>
                        <th>Completed</th>
                        <th title="Number of tickets where assignee failed to respond within SLA after being assigned">Assignee Response Breached</th>
                        <th>Avg Resolution Time (days)</th>
                    </tr>
                </thead>
                <tbody id="assignee-tbody">
                    <tr><td colspan="6" style="text-align:center; color:#999;">Click "Refresh Metrics" to load data</td></tr>
                </tbody>
            </table>
        </div>

        <div class="issues-table">
            <h2 style="margin-bottom: 20px; color: #333; display: inline-block;">Issue Details</h2>
            <div style="display: inline-block; margin-left: 20px;">
                <label for="assignee-filter" style="color: #666; font-size: 0.9em; margin-right: 8px;">Filter by Assignee:</label>
                <select id="assignee-filter" onchange="filterByAssignee()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; background: white; cursor: pointer;">
                    <option value="">All Assignees</option>
                </select>
            </div>
            <p style="color: #666; font-size: 0.85em; margin-top: 10px; font-style: italic;">
                üí° <strong>Response SLA:</strong> Did the assignee respond within 4 hours? | <strong>Time to Resolution:</strong> How long to fix? (üü¢ <24h, üü° 1-3d, üü† 3-7d, üî¥ >7d)
            </p>
            <table>
                <thead>
                    <tr>
                        <th>Key</th>
                        <th>Summary</th>
                        <th>Status</th>
                        <th>Priority</th>
                        <th>Assignee</th>
                        <th>Created</th>
                        <th>Assigned</th>
                        <th>First Response</th>
                        <th>Closed</th>
                        <th title="Did the assignee respond within SLA after being assigned?">Response SLA</th>
                        <th title="Time from assignment to resolution (informational - not SLA)">Time to Resolution</th>
                        <th>Open (days)</th>
                    </tr>
                </thead>
                <tbody id="issues-tbody">
                    <tr><td colspan="12" style="text-align:center; color:#999;">Click "Refresh Metrics" to load data</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Date Configuration Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üìÖ Configure Date Range</div>
            <div class="form-group">
                <label for="startDate">Start Date</label>
                <input type="date" id="startDate" value="2025-11-01">
            </div>
            <div class="form-group">
                <label for="endDate">End Date</label>
                <input type="date" id="endDate" value="2025-11-19">
            </div>
            <div class="form-group">
                <label for="maxIssues">Max Issues (leave empty for all)</label>
                <input type="number" id="maxIssues" placeholder="e.g., 25, 50, 100" value="50">
            </div>
            <div class="button-group">
                <button class="btn btn-secondary" onclick="closeConfig()">Cancel</button>
                <button class="btn btn-primary" onclick="saveAndRun()">Save & Run Collection</button>
            </div>
        </div>
    </div>

    <script>
        function minutesToDays(minutes) {
            if (minutes === null || minutes === undefined) return '--';
            return (minutes / 1440).toFixed(1);
        }

        function getStatusClass(status) {
            if (!status) return 'status-todo';
            const s = status.toLowerCase();
            if (s.includes('done') || s.includes('resolved')) return 'status-done';
            if (s.includes('progress')) return 'status-progress';
            return 'status-todo';
        }

        function toggleManager(managerId) {
            const rows = document.querySelectorAll(`#${managerId}-row`);
            const icon = document.getElementById(`icon-${managerId}`);
            const isExpanded = rows[0] && rows[0].style.display !== 'none';
            
            rows.forEach(row => {
                row.style.display = isExpanded ? 'none' : 'table-row';
            });
            
            if (icon) {
                icon.classList.toggle('expanded', !isExpanded);
            }
        }

        function toggleSLATickets(slaCategoryId) {
            event.stopPropagation(); // Prevent triggering parent row toggle
            const ticketRows = document.querySelectorAll(`#${slaCategoryId}-ticket`);
            const icon = document.getElementById(`icon-${slaCategoryId}`);
            const isExpanded = ticketRows[0] && ticketRows[0].style.display !== 'none';
            
            ticketRows.forEach(row => {
                row.style.display = isExpanded ? 'none' : 'table-row';
            });
            
            if (icon) {
                icon.classList.toggle('expanded', !isExpanded);
            }
        }

        function toggleOnCallBreaches(personId) {
            const rows = document.querySelectorAll(`#${personId}-breach`);
            const icon = document.getElementById(`icon-${personId}`);
            const isExpanded = rows[0] && rows[0].style.display !== 'none';
            
            rows.forEach(row => {
                row.style.display = isExpanded ? 'none' : 'table-row';
            });
            
            if (icon) {
                icon.classList.toggle('expanded', !isExpanded);
            }
        }

        function toggleOnCallDetails(personId) {
            const rows = document.querySelectorAll(`#${personId}-detail`);
            const icon = document.getElementById(`icon-${personId}`);
            const isExpanded = rows[0] && rows[0].style.display !== 'none';
            
            rows.forEach(row => {
                row.style.display = isExpanded ? 'none' : 'table-row';
            });
            
            if (icon) {
                icon.classList.toggle('expanded', !isExpanded);
            }
        }

        function toggleAllOnCallDetails() {
            const allDetailRows = document.querySelectorAll('.oncall-detail-row');
            const allIcons = document.querySelectorAll('[id^="icon-oncall-person-"]');
            const toggleIcon = document.getElementById('toggle-all-icon');
            
            // Check if any are currently expanded
            const anyExpanded = Array.from(allDetailRows).some(row => row.style.display !== 'none');
            
            // Toggle all to opposite state
            allDetailRows.forEach(row => {
                row.style.display = anyExpanded ? 'none' : 'table-row';
            });
            
            allIcons.forEach(icon => {
                if (anyExpanded) {
                    icon.classList.remove('expanded');
                } else {
                    icon.classList.add('expanded');
                }
            });
            
            // Update button icon
            toggleIcon.textContent = anyExpanded ? '‚ñº' : '‚ñ≤';
        }

        // Store all metrics data globally for filtering
        let allMetricsData = [];

        function filterByAssignee() {
            const selectedAssignee = document.getElementById('assignee-filter').value;
            const tbody = document.getElementById('issues-tbody');
            
            // Filter data
            const filteredData = selectedAssignee === '' 
                ? allMetricsData 
                : allMetricsData.filter(issue => (issue.assigneeCurrent || 'Unassigned') === selectedAssignee);
            
            // Re-render table with filtered data
            renderIssuesTable(filteredData);
        }

        function renderIssuesTable(metrics) {
            const tbody = document.getElementById('issues-tbody');
            const rows = metrics.map(issue => {
                let slaStatus = '--';
                if (issue.sla && issue.sla.length > 0) {
                    const firstSla = issue.sla[0];
                    const goalMinutes = firstSla.goalDuration ? (firstSla.goalDuration / (1000 * 60)) : null;
                    const goalHours = goalMinutes ? (goalMinutes / 60).toFixed(0) : '?';
                    
                    // Recalculate SLA status based on ON-CALL response time (using BUSINESS HOURS)
                    if (goalMinutes !== null && issue.businessHoursToFirstOnCallAction !== null) {
                        const businessHours = (issue.businessHoursToFirstOnCallAction / 60).toFixed(1);
                        if (issue.businessHoursToFirstOnCallAction > goalMinutes) {
                            slaStatus = `<span style="color: #dc3545; font-weight: bold;">‚ö†Ô∏è Breached (${businessHours}h)</span>`;
                        } else {
                            slaStatus = `<span style="color: #28a745;">‚úì Met (${businessHours}h)</span>`;
                        }
                    } else if (issue.businessHoursToFirstOnCallAction === null) {
                        // No on-call action yet - check if overdue (using business hours)
                        const createdDate = new Date(issue.created);
                        const now = new Date();
                        // For business hours calculation, we need to import the businessHours module
                        // For now, use a simple check - if created outside hours, show pending without overdue
                        const elapsedMinutes = (now - createdDate) / (1000 * 60);
                        if (issue.createdOutsideBusinessHours) {
                            slaStatus = `<span style="color: #856404;">‚è≥ Pending (created after hours)</span>`;
                        } else if (elapsedMinutes > goalMinutes) {
                            slaStatus = `<span style="color: #dc3545; font-weight: bold;">‚ö†Ô∏è Pending (overdue)</span>`;
                        } else {
                            const hoursRemaining = ((goalMinutes - elapsedMinutes) / 60).toFixed(1);
                            slaStatus = `<span style="color: #856404;">‚è≥ ${hoursRemaining}h left</span>`;
                        }
                    } else {
                        slaStatus = `<span style="color: #666;">Goal: ${goalHours}h</span>`;
                    }
                }
                
                // Format dates
                const createdDate = issue.created ? new Date(issue.created).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '--';
                
                // Determine first action (assignment or comment, whichever came first)
                let firstAction = '--';
                const assignTime = issue.firstAssignmentTime ? new Date(issue.firstAssignmentTime) : null;
                const commentTime = issue.firstAssigneeCommentTime ? new Date(issue.firstAssigneeCommentTime) : null;
                const onCallTime = issue.firstOnCallActionTime ? new Date(issue.firstOnCallActionTime) : null;
                
                // Use the earliest action time
                const times = [assignTime, commentTime, onCallTime].filter(t => t !== null);
                if (times.length > 0) {
                    const earliest = new Date(Math.min(...times));
                    firstAction = earliest.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                }
                
                // Map email usernames to full names for display
                const emailToNameMap = {
                    'bgoldberg': 'Brad Goldberg',
                    'jmaciorowski': 'Jeff Maciorowski',
                    'atakkar': 'Akshay Vijay Takkar',
                    'gsemenenko': 'Grigoriy Semenenko',
                    'rdahl': 'Randy Dahl',
                    'esuhov': 'Evgeniy Suhov',
                    'mkulkin': 'Max Kuklin'
                };
                
                // Highlight on-call mismatch
                const assignedBy = issue.assignedBy || '--';
                const whoWasOnCallEmail = issue.whoWasOnCall;
                
                // Check if it's a special label (Weekend, After Hours, etc.)
                const isSpecialLabel = whoWasOnCallEmail && (
                    whoWasOnCallEmail.startsWith('[') && whoWasOnCallEmail.endsWith(']')
                );
                
                const whoWasOnCall = whoWasOnCallEmail ? (
                    isSpecialLabel ? whoWasOnCallEmail : (emailToNameMap[whoWasOnCallEmail] || whoWasOnCallEmail)
                ) : '--';
                
                let assignedByDisplay = assignedBy;
                let onCallDisplay = whoWasOnCall;
                
                // Style special labels differently
                if (isSpecialLabel) {
                    onCallDisplay = `<span style="color: #999; font-style: italic; font-size: 0.9em;">${whoWasOnCall}</span>`;
                    // Don't flag as mismatch if it's a special case
                } else if (assignedBy !== '--' && whoWasOnCall !== '--' && assignedBy !== whoWasOnCall) {
                    // If we have both values and they differ, highlight the mismatch
                    assignedByDisplay = `<span style="color: #dc3545; font-weight: bold;" title="Wrong person responded - ${whoWasOnCall} was on-call">‚ö†Ô∏è ${assignedBy}</span>`;
                    onCallDisplay = `<span style="color: #28a745; font-weight: bold;">${whoWasOnCall}</span>`;
                } else if (assignedBy === '--' && whoWasOnCall !== '--') {
                    // If no one responded but someone was on-call, highlight as missed
                    assignedByDisplay = '<span style="color: #dc3545;" title="No response from on-call person">‚ùå No response</span>';
                    onCallDisplay = `<span style="color: #dc3545; font-weight: bold;" title="Missed on-call response">${whoWasOnCall}</span>`;
                }
                
                // Calculate Assignee Response SLA status (did they respond?)
                let assigneeSlaStatus = '--';
                let timeToResolution = '--';
                
                if (issue.sla && issue.sla.length > 0 && issue.firstAssignmentTime) {
                    const firstSla = issue.sla[0];
                    const goalMinutes = firstSla.goalDuration ? (firstSla.goalDuration / (1000 * 60)) : null;
                    const goalHours = goalMinutes ? (goalMinutes / 60).toFixed(0) : '?';
                    
                    // Calculate time to resolution (informational, not SLA)
                    if (issue.resolutionDate) {
                        const assignmentDate = new Date(issue.firstAssignmentTime);
                        const resolutionDate = new Date(issue.resolutionDate);
                        const resolutionDays = ((resolutionDate - assignmentDate) / (1000 * 60 * 60 * 24)).toFixed(1);
                        const resolutionHours = ((resolutionDate - assignmentDate) / (1000 * 60 * 60)).toFixed(1);
                        
                        // Color code based on resolution time
                        let resolutionColor = '#28a745'; // green
                        if (resolutionHours > 168) resolutionColor = '#dc3545'; // red (>7 days)
                        else if (resolutionHours > 72) resolutionColor = '#fd7e14'; // orange (>3 days)
                        else if (resolutionHours > 24) resolutionColor = '#ffc107'; // yellow (>1 day)
                        
                        timeToResolution = `<span style="color: ${resolutionColor}; font-weight: 500;">${resolutionDays}d (${resolutionHours}h)</span>`;
                    } else {
                        // Still open - show elapsed time since assignment
                        const assignmentDate = new Date(issue.firstAssignmentTime);
                        const now = new Date();
                        const elapsedDays = ((now - assignmentDate) / (1000 * 60 * 60 * 24)).toFixed(1);
                        const elapsedHours = ((now - assignmentDate) / (1000 * 60 * 60)).toFixed(1);
                        
                        // Color code based on elapsed time
                        let elapsedColor = '#6c757d'; // gray
                        if (elapsedHours > 168) elapsedColor = '#dc3545'; // red (>7 days)
                        else if (elapsedHours > 72) elapsedColor = '#fd7e14'; // orange (>3 days)
                        else if (elapsedHours > 24) elapsedColor = '#ffc107'; // yellow (>1 day)
                        
                        timeToResolution = `<span style="color: ${elapsedColor}; font-weight: 500;" title="Still open">${elapsedDays}d (${elapsedHours}h) ‚è≥</span>`;
                    }
                    
                    // Check response SLA (did assignee comment?)
                    if (goalMinutes !== null) {
                        if (issue.businessHoursToFirstAssigneeComment !== null) {
                            // Assignee has commented - check if within SLA (using business hours)
                            const businessHours = (issue.businessHoursToFirstAssigneeComment / 60).toFixed(1);
                            if (issue.businessHoursToFirstAssigneeComment > goalMinutes) {
                                assigneeSlaStatus = `<span style="color: #dc3545; font-weight: bold;">‚ö†Ô∏è Breached (${businessHours}h)</span>`;
                            } else {
                                assigneeSlaStatus = `<span style="color: #28a745;">‚úì Responded (${businessHours}h)</span>`;
                            }
                        } else if (issue.resolutionDate) {
                            // No comment but ticket is resolved - check if resolved quickly (implicit response)
                            const assignmentDate = new Date(issue.firstAssignmentTime);
                            const resolutionDate = new Date(issue.resolutionDate);
                            const resolutionMinutes = (resolutionDate - assignmentDate) / (1000 * 60);
                            if (resolutionMinutes <= goalMinutes) {
                                assigneeSlaStatus = `<span style="color: #28a745;" title="Resolved quickly without comment">‚úì Resolved fast</span>`;
                            } else {
                                assigneeSlaStatus = `<span style="color: #ffc107;" title="Resolved without commenting">‚ö†Ô∏è No response</span>`;
                            }
                        } else {
                            // No comment and not resolved - check if overdue
                            const assignmentDate = new Date(issue.firstAssignmentTime);
                            const now = new Date();
                            const elapsedMinutes = (now - assignmentDate) / (1000 * 60);
                            if (elapsedMinutes > goalMinutes) {
                                assigneeSlaStatus = `<span style="color: #dc3545; font-weight: bold;">‚ö†Ô∏è No response (overdue)</span>`;
                            } else {
                                const hoursRemaining = ((goalMinutes - elapsedMinutes) / 60).toFixed(1);
                                assigneeSlaStatus = `<span style="color: #856404;">‚è≥ ${hoursRemaining}h to respond</span>`;
                            }
                        }
                    }
                } else if (!issue.firstAssignmentTime) {
                    assigneeSlaStatus = '<span style="color: #999;">Not assigned</span>';
                    timeToResolution = '<span style="color: #999;">--</span>';
                }
                
                // Format assignment date
                const assignedDate = issue.firstAssignmentTime ? new Date(issue.firstAssignmentTime).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '--';
                
                // Format first response (assignee comment)
                const firstResponse = issue.firstAssigneeCommentTime ? new Date(issue.firstAssigneeCommentTime).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '--';
                
                // Format closed/resolution date
                const closedDate = issue.resolutionDate ? new Date(issue.resolutionDate).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '--';
                
                return `
                    <tr>
                        <td><a href="https://m3gr.atlassian.net/browse/${issue.key}" target="_blank" style="color: #667eea; font-weight: bold; text-decoration: none;">${issue.key}</a></td>
                        <td>${issue.summary || ''}</td>
                        <td><span class="status-badge ${getStatusClass(issue.status)}">${issue.status || 'Unknown'}</span></td>
                        <td>${issue.priority || 'None'}</td>
                        <td>${issue.assigneeCurrent || 'Unassigned'}</td>
                        <td style="font-size: 0.85em; color: #666;">${createdDate}</td>
                        <td style="font-size: 0.85em; color: #667eea;">${assignedDate}</td>
                        <td style="font-size: 0.85em; color: #667eea; font-weight: 500;">${firstResponse}</td>
                        <td style="font-size: 0.85em; color: #28a745;">${closedDate}</td>
                        <td>${assigneeSlaStatus}</td>
                        <td>${timeToResolution}</td>
                        <td>${minutesToDays(issue.openDurationMinutes)}</td>
                    </tr>
                `;
            }).join('');
            
            tbody.innerHTML = rows || '<tr><td colspan="11" style="text-align:center; color:#999;">No issues found</td></tr>';
        }

        async function loadLatestMetrics() {
            const errorDiv = document.getElementById('error-msg');
            errorDiv.style.display = 'none';
            
            try {
                // Try to get list from API first
                let latestFile = null;
                
                try {
                    const listResponse = await fetch('/api/metrics-files');
                    if (listResponse.ok) {
                        const filesList = await listResponse.json();
                        if (filesList.files && filesList.files.length > 0) {
                            latestFile = filesList.files[filesList.files.length - 1];
                        }
                    }
                } catch (e) {
                    console.log('API not available, trying direct file access');
                }
                
                // If no file found via API, try the most recent known file
                if (!latestFile) {
                    latestFile = 'metrics-2025-11-19T15-35-09-149Z.json';
                }
                
                const response = await fetch(`/data/${latestFile}`);
                if (!response.ok) throw new Error('Failed to load metrics file');
                
                const data = await response.json();
                
                console.log('Loaded data:', data);
                
                // Extract and display date range from config
                const saved = JSON.parse(localStorage.getItem('jiraConfig') || '{}');
                const dateRangeText = saved.startDate && saved.endDate 
                    ? `(${saved.startDate} to ${saved.endDate})`
                    : '';
                document.getElementById('date-range').textContent = dateRangeText;
                document.getElementById('oncall-date-range').textContent = saved.startDate && saved.endDate 
                    ? `Date Range: ${saved.startDate} to ${saved.endDate}`
                    : 'Date Range: Not configured';
                
                // Update summary metrics
                document.getElementById('total-count').textContent = data.summary.count || 0;
                document.getElementById('avg-open').textContent = minutesToDays(data.summary.avgOpenDurationMinutes);
                document.getElementById('avg-resolution').textContent = minutesToDays(data.summary.avgTimeToResolutionMinutes);
                // Display business hours metric if available, fall back to actual minutes
                const avgCommentMinutes = data.summary.avgBusinessHoursToFirstAssigneeComment || data.summary.avgTimeToFirstAssigneeCommentMinutes;
                document.getElementById('avg-comment').textContent = minutesToDays(avgCommentMinutes);
                document.getElementById('timestamp').textContent = `Last Updated: ${new Date(data.generatedAt).toLocaleString()}`;
                
                // Calculate ticket creation overview
                let onCallCount = 0;
                let outsideCount = 0;
                const breakdownByPerson = {};
                const outsideReasons = { weekend: 0, afterHours: 0, beforeSchedule: 0 };
                
                data.metrics.forEach(issue => {
                    const whoWasOnCall = issue.whoWasOnCall;
                    if (whoWasOnCall) {
                        if (whoWasOnCall.startsWith('[') && whoWasOnCall.endsWith(']')) {
                            // Outside coverage
                            outsideCount++;
                            if (whoWasOnCall === '[Weekend]') outsideReasons.weekend++;
                            else if (whoWasOnCall === '[After Hours]') outsideReasons.afterHours++;
                            else if (whoWasOnCall === '[Before Oct 31]') outsideReasons.beforeSchedule++;
                        } else {
                            // During on-call hours
                            onCallCount++;
                            breakdownByPerson[whoWasOnCall] = (breakdownByPerson[whoWasOnCall] || 0) + 1;
                        }
                    }
                });
                
                // Email to name mapping
                const emailToName = {
                    'bgoldberg': 'Brad',
                    'jmaciorowski': 'Jeff',
                    'atakkar': 'Akshay',
                    'gsemenenko': 'Grigoriy',
                    'rdahl': 'Randy',
                    'esuhov': 'Evgeniy',
                    'mkulkin': 'Max'
                };
                
                // Update overview section
                document.getElementById('overview-total').textContent = data.summary.count || 0;
                document.getElementById('overview-oncall').textContent = onCallCount;
                document.getElementById('overview-outside').textContent = outsideCount;
                
                // Build breakdown text
                let breakdownHtml = '<strong>Tickets by On-Call Person:</strong> ';
                const personBreakdown = Object.entries(breakdownByPerson)
                    .map(([email, count]) => `${emailToName[email] || email} (${count})`)
                    .join(', ');
                breakdownHtml += personBreakdown || 'None';
                
                if (outsideCount > 0) {
                    breakdownHtml += '<br><strong>Outside Coverage:</strong> ';
                    const outsideBreakdown = [];
                    if (outsideReasons.weekend > 0) outsideBreakdown.push(`${outsideReasons.weekend} weekend`);
                    if (outsideReasons.afterHours > 0) outsideBreakdown.push(`${outsideReasons.afterHours} after-hours`);
                    if (outsideReasons.beforeSchedule > 0) outsideBreakdown.push(`${outsideReasons.beforeSchedule} before schedule`);
                    breakdownHtml += outsideBreakdown.join(', ');
                }
                
                document.getElementById('overview-breakdown').innerHTML = breakdownHtml;
                
                // Calculate SLA metrics split by on-call hours vs after-hours
                let onCallHoursTotal = 0, onCallHoursMet = 0, onCallHoursBreached = 0;
                let afterHoursTotal = 0, afterHoursMet = 0, afterHoursBreached = 0;
                let overallTotal = 0, overallMet = 0, overallBreached = 0;
                
                data.metrics.forEach(issue => {
                    const whoWasOnCall = issue.whoWasOnCall;
                    const isOffHours = whoWasOnCall && (
                        whoWasOnCall === '[Weekend]' || 
                        whoWasOnCall === '[After Hours]' || 
                        whoWasOnCall === '[Before Oct 31]'
                    );
                    
                    // Check SLA status based on on-call response time (using business hours)
                    if (issue.sla && issue.sla.length > 0 && issue.businessHoursToFirstOnCallAction !== null) {
                        const firstSla = issue.sla[0];
                        const goalMinutes = firstSla.goalDuration ? firstSla.goalDuration / (1000 * 60) : null;
                        
                        if (goalMinutes !== null) {
                            const breached = issue.businessHoursToFirstOnCallAction > goalMinutes;
                            
                            // Overall stats
                            overallTotal++;
                            if (breached) {
                                overallBreached++;
                            } else {
                                overallMet++;
                            }
                            
                            // Split by on-call vs after-hours
                            if (isOffHours) {
                                afterHoursTotal++;
                                if (breached) {
                                    afterHoursBreached++;
                                } else {
                                    afterHoursMet++;
                                }
                            } else {
                                onCallHoursTotal++;
                                if (breached) {
                                    onCallHoursBreached++;
                                } else {
                                    onCallHoursMet++;
                                }
                            }
                        }
                    }
                });
                
                // Update SLA metric cards
                const onCallCompliance = onCallHoursTotal > 0 
                    ? ((onCallHoursMet / onCallHoursTotal) * 100).toFixed(1)
                    : '--';
                const afterHoursCompliance = afterHoursTotal > 0
                    ? ((afterHoursMet / afterHoursTotal) * 100).toFixed(1)
                    : '--';
                const overallCompliance = overallTotal > 0
                    ? ((overallMet / overallTotal) * 100).toFixed(1)
                    : '--';
                
                document.getElementById('oncall-sla').textContent = onCallCompliance !== '--' 
                    ? `${onCallCompliance}% (${onCallHoursMet}/${onCallHoursTotal})`
                    : '--';
                document.getElementById('afterhours-sla').textContent = afterHoursCompliance !== '--'
                    ? `${afterHoursCompliance}% (${afterHoursMet}/${afterHoursTotal})`
                    : '--';
                document.getElementById('overall-sla').textContent = overallCompliance !== '--'
                    ? `${overallCompliance}% (${overallMet}/${overallTotal})`
                    : '--';
                
                document.getElementById('timestamp').textContent = `Last Updated: ${new Date(data.generatedAt).toLocaleString()}`;
                
                console.log('Updated summary cards');
                
                // Store all metrics for filtering
                allMetricsData = data.metrics;
                
                // Populate assignee filter dropdown
                const assignees = [...new Set(data.metrics.map(issue => issue.assigneeCurrent || 'Unassigned'))].sort();
                const assigneeFilter = document.getElementById('assignee-filter');
                assigneeFilter.innerHTML = '<option value="">All Assignees</option>' + 
                    assignees.map(assignee => `<option value="${assignee}">${assignee}</option>`).join('');
                
                // Render initial table with all data
                renderIssuesTable(data.metrics);
                console.log('Updated table with', data.metrics.length, 'rows');
                
                // Calculate assignee statistics (exclude Unassigned)
                const assigneeStats = {};
                const doneStatuses = ['done', 'closed', 'complete', 'completed', 'resolved'];
                
                data.metrics.forEach(issue => {
                    const assignee = issue.assigneeCurrent;
                    if (!assignee) return; // Skip unassigned tickets
                    if (!assigneeStats[assignee]) {
                        assigneeStats[assignee] = {
                            total: 0,
                            active: 0,
                            completed: 0,
                            breached: 0,
                            resolutionTimes: []
                        };
                    }
                    assigneeStats[assignee].total++;
                    
                    // Check if assignee breached SLA on their response time
                    if (issue.sla && issue.sla.length > 0 && issue.firstAssignmentTime) {
                        const goalMinutes = issue.sla[0].goalDuration ? issue.sla[0].goalDuration / (1000 * 60) : null;
                        
                        if (goalMinutes !== null) {
                            if (issue.businessHoursToFirstAssigneeComment !== null) {
                                // Has commented - check if it was within SLA (using business hours)
                                if (issue.businessHoursToFirstAssigneeComment > goalMinutes) {
                                    assigneeStats[assignee].breached++;
                                }
                            } else if (issue.resolutionDate) {
                                // No comment but resolved - check if resolved within SLA
                                const assignmentDate = new Date(issue.firstAssignmentTime);
                                const resolutionDate = new Date(issue.resolutionDate);
                                const resolutionMinutes = (resolutionDate - assignmentDate) / (1000 * 60);
                                if (resolutionMinutes > goalMinutes) {
                                    assigneeStats[assignee].breached++;
                                }
                            } else {
                                // No comment and not resolved - check if overdue
                                const assignmentDate = new Date(issue.firstAssignmentTime);
                                const now = new Date();
                                const elapsedMinutes = (now - assignmentDate) / (1000 * 60);
                                if (elapsedMinutes > goalMinutes) {
                                    assigneeStats[assignee].breached++;
                                }
                            }
                        }
                    }
                    
                    const status = (issue.status || '').toLowerCase();
                    const isCompleted = doneStatuses.some(s => status.includes(s)) || issue.resolutionDate;
                    
                    if (isCompleted) {
                        assigneeStats[assignee].completed++;
                        if (issue.timeToResolutionMinutes !== null) {
                            assigneeStats[assignee].resolutionTimes.push(issue.timeToResolutionMinutes);
                        }
                    } else {
                        assigneeStats[assignee].active++;
                    }
                });
                
                // Update assignee table
                const assigneeTbody = document.getElementById('assignee-tbody');
                const assigneeRows = Object.entries(assigneeStats)
                    .sort((a, b) => b[1].total - a[1].total)
                    .map(([assignee, stats]) => {
                        const avgResolution = stats.resolutionTimes.length > 0
                            ? minutesToDays(stats.resolutionTimes.reduce((a, b) => a + b, 0) / stats.resolutionTimes.length)
                            : '--';
                        return `
                            <tr>
                                <td><strong>${assignee}</strong></td>
                                <td>${stats.total}</td>
                                <td><strong style="color: ${stats.active > 0 ? '#856404' : '#28a745'}">${stats.active}</strong></td>
                                <td>${stats.completed}</td>
                                <td><strong style="color: ${stats.breached > 0 ? '#d9534f' : '#28a745'}">${stats.breached}</strong></td>
                                <td>${avgResolution}</td>
                            </tr>
                        `;
                    }).join('');
                
                assigneeTbody.innerHTML = assigneeRows;
                console.log('Updated assignee stats for', Object.keys(assigneeStats).length, 'assignees');
                
                // Calculate on-call compliance metrics
                console.log('[DEBUG] Starting on-call compliance calculation');
                const onCallStats = {};
                const ON_CALL_MANAGERS = ['Brad Goldberg', 'Jeff Maciorowski', 'Akshay Vijay Takkar', 'Grigoriy Semenenko', 'Randy Dahl', 'Evgeniy Suhov', 'Max Kuklin'];
                
                // Map email usernames to full names
                const emailToNameMap = {
                    'bgoldberg': 'Brad Goldberg',
                    'jmaciorowski': 'Jeff Maciorowski',
                    'atakkar': 'Akshay Vijay Takkar',
                    'gsemenenko': 'Grigoriy Semenenko',
                    'rdahl': 'Randy Dahl',
                    'esuhov': 'Evgeniy Suhov',
                    'mkulkin': 'Max Kuklin'
                };
                
                // Initialize all on-call people
                ON_CALL_MANAGERS.forEach(person => {
                    onCallStats[person] = {
                        ticketsDuringShift: 0,
                        respondedTo: 0,
                        someoneElseHandled: 0,
                        noResponse: 0,
                        responseTimes: [],
                        breachedTickets: [],
                        metTickets: [],
                        slaMetCount: 0,
                        slaBreachedCount: 0
                    };
                });
                
                data.metrics.forEach(issue => {
                    const whoWasOnCallEmail = issue.whoWasOnCall;
                    
                    // Skip special labels like [Weekend], [After Hours], etc.
                    if (!whoWasOnCallEmail || (whoWasOnCallEmail.startsWith('[') && whoWasOnCallEmail.endsWith(']'))) {
                        return;
                    }
                    
                    const whoWasOnCall = emailToNameMap[whoWasOnCallEmail] || whoWasOnCallEmail;
                    const assignedBy = issue.assignedBy;
                    
                    // Track tickets created during each person's on-call shift
                    if (whoWasOnCall && ON_CALL_MANAGERS.includes(whoWasOnCall)) {
                        const stats = onCallStats[whoWasOnCall];
                        stats.ticketsDuringShift++;
                        
                        // Check if SLA was breached or met (using business hours)
                        if (issue.sla && issue.sla.length > 0 && issue.businessHoursToFirstOnCallAction !== null) {
                            const firstSla = issue.sla[0];
                            const goalMinutes = firstSla.goalDuration ? firstSla.goalDuration / (1000 * 60) : null;
                            if (goalMinutes !== null) {
                                // Debug logging for ticket 15277
                                if (issue.key === 'M3GRSC-15277') {
                                    console.log('[DEBUG 15277]', 'Business hours:', issue.businessHoursToFirstOnCallAction, 'Goal:', goalMinutes, 'Breach?', issue.businessHoursToFirstOnCallAction > goalMinutes);
                                }
                                if (issue.businessHoursToFirstOnCallAction > goalMinutes) {
                                    stats.slaBreachedCount++;
                                    stats.breachedTickets.push({
                                        key: issue.key,
                                        summary: issue.summary,
                                        responseTime: (issue.businessHoursToFirstOnCallAction / 60).toFixed(1),
                                        goalTime: (goalMinutes / 60).toFixed(1),
                                        created: issue.created,
                                        firstActionTime: issue.firstOnCallActionTime,
                                        actionType: issue.firstOnCallActionType
                                    });
                                } else {
                                    stats.slaMetCount++;
                                    stats.metTickets.push({
                                        key: issue.key,
                                        summary: issue.summary,
                                        responseTime: (issue.businessHoursToFirstOnCallAction / 60).toFixed(1),
                                        goalTime: (goalMinutes / 60).toFixed(1)
                                    });
                                }
                            }
                        }
                        
                        if (!assignedBy) {
                            stats.noResponse++;
                        } else if (assignedBy === whoWasOnCall) {
                            stats.respondedTo++;
                            if (issue.businessHoursToFirstOnCallAction !== null) {
                                stats.responseTimes.push(issue.businessHoursToFirstOnCallAction);
                            }
                        } else {
                            stats.someoneElseHandled++;
                        }
                    }
                });
                
                const oncallTbody = document.getElementById('oncall-tbody');
                let oncallRowsHtml = '';
                
                Object.entries(onCallStats)
                    .sort((a, b) => b[1].ticketsDuringShift - a[1].ticketsDuringShift)
                    .forEach(([person, stats], idx) => {
                        const totalWithSla = stats.slaMetCount + stats.slaBreachedCount;
                        const complianceRate = totalWithSla > 0
                            ? ((stats.slaMetCount / totalWithSla) * 100).toFixed(0)
                            : '--';
                        
                        const avgResponseTime = stats.responseTimes.length > 0
                            ? (stats.responseTimes.reduce((a, b) => a + b, 0) / stats.responseTimes.length / 60).toFixed(1)
                            : '--';
                        
                        const complianceColor = complianceRate !== '--' && complianceRate >= 80 ? '#28a745' : 
                                               complianceRate !== '--' && complianceRate >= 50 ? '#856404' : 
                                               complianceRate !== '--' ? '#dc3545' : '#999';
                        
                        const rowStyle = stats.ticketsDuringShift === 0 ? 'color: #999; font-style: italic;' : '';
                        const hasBreaches = stats.breachedTickets.length > 0;
                        const hasMet = stats.metTickets.length > 0;
                        const hasDetails = hasBreaches || hasMet;
                        const personId = `oncall-person-${idx}`;
                        
                        // Main row - clickable if has details
                        const rowClass = hasDetails ? 'expandable' : '';
                        const rowClick = hasDetails ? `onclick="toggleOnCallDetails('${personId}')"` : '';
                        const caret = hasDetails ? `<span class="expand-icon" id="icon-${personId}">‚ñ∂</span> ` : '';
                        
                        const detailsLabel = [];
                        if (hasBreaches) detailsLabel.push(`${stats.breachedTickets.length} breached`);
                        if (hasMet) detailsLabel.push(`${stats.metTickets.length} met`);
                        const detailsText = detailsLabel.length > 0 ? ` <span style="color: #666; font-size: 0.85em;">(${detailsLabel.join(', ')})</span>` : '';
                        
                        oncallRowsHtml += `
                            <tr class="${rowClass}" ${rowClick} style="${rowStyle}">
                                <td>${caret}<strong>${person}</strong>${detailsText}</td>
                                <td style="text-align: center;">${stats.ticketsDuringShift}</td>
                                <td style="text-align: center; color: #28a745; font-weight: bold;">${stats.respondedTo}</td>
                                <td style="text-align: center; color: #856404;">${stats.someoneElseHandled}</td>
                                <td style="text-align: center; color: ${stats.noResponse > 0 ? '#dc3545' : '#666'};">${stats.noResponse}</td>
                                <td style="text-align: center; color: ${complianceColor}; font-weight: bold;">${complianceRate !== '--' ? complianceRate + '%' : '--'}</td>
                                <td style="text-align: center;">${avgResponseTime}${avgResponseTime !== '--' ? 'h' : ''}</td>
                            </tr>
                        `;
                        
                        // Breach detail rows
                        if (hasBreaches) {
                            stats.breachedTickets.forEach(ticket => {
                                const createdDate = new Date(ticket.created);
                                const actionDate = ticket.firstActionTime ? new Date(ticket.firstActionTime) : null;
                                const createdStr = createdDate.toLocaleString('en-US', { 
                                    month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true 
                                });
                                const actionStr = actionDate ? actionDate.toLocaleString('en-US', { 
                                    month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true 
                                }) : 'No response';
                                const actionTypeStr = ticket.actionType === 'comment' ? 'commented' : 'assigned';
                                
                                oncallRowsHtml += `
                                    <tr class="oncall-detail-row" id="${personId}-detail" style="display:none; background: #fff3f3;">
                                        <td style="padding-left: 40px;">
                                            ‚îî‚îÄ <a href="https://m3gr.atlassian.net/browse/${ticket.key}" target="_blank" style="color: #dc3545; font-weight: bold; text-decoration: none;">${ticket.key}</a>
                                        </td>
                                        <td colspan="3" style="font-size: 0.9em; color: #666;">
                                            ${ticket.summary}
                                            <div style="font-size: 0.85em; color: #999; margin-top: 4px;">
                                                üìÖ Created: ${createdStr} ‚Üí ${actionDate ? actionTypeStr : 'no action'}: ${actionStr}
                                            </div>
                                        </td>
                                        <td colspan="2" style="text-align: center; color: #dc3545;">‚ö†Ô∏è ${ticket.responseTime}h (goal: ${ticket.goalTime}h)</td>
                                        <td></td>
                                    </tr>
                                `;
                            });
                        }
                        
                        // Met ticket rows (now expandable)
                        if (hasMet) {
                            stats.metTickets.forEach(ticket => {
                                oncallRowsHtml += `
                                    <tr class="oncall-detail-row" id="${personId}-detail" style="display:none; background: #f0f9ff;">
                                        <td style="padding-left: 40px;">
                                            ‚îî‚îÄ <a href="https://m3gr.atlassian.net/browse/${ticket.key}" target="_blank" style="color: #28a745; font-weight: bold; text-decoration: none;">${ticket.key}</a>
                                        </td>
                                        <td colspan="3" style="font-size: 0.9em; color: #666;">${ticket.summary}</td>
                                        <td colspan="2" style="text-align: center; color: #28a745;">‚úì ${ticket.responseTime}h (goal: ${ticket.goalTime}h)</td>
                                        <td></td>
                                    </tr>
                                `;
                            });
                        }
                    });
                
                oncallTbody.innerHTML = oncallRowsHtml || '<tr><td colspan="7" style="text-align:center; color:#999;">No on-call data available</td></tr>';
                console.log('Updated on-call stats for', Object.keys(onCallStats).length, 'people');
                
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.style.display = 'block';
                console.error('Error loading metrics:', error);
            }
        }

        // Auto-load on page load
        window.addEventListener('load', loadLatestMetrics);

        function openConfig() {
            // Load current values from localStorage if available
            const saved = JSON.parse(localStorage.getItem('jiraConfig') || '{}');
            document.getElementById('startDate').value = saved.startDate || '2025-11-01';
            document.getElementById('endDate').value = saved.endDate || new Date().toISOString().split('T')[0];
            document.getElementById('maxIssues').value = saved.maxIssues || '50';
            document.getElementById('configModal').style.display = 'block';
        }

        function closeConfig() {
            document.getElementById('configModal').style.display = 'none';
        }

        async function saveAndRun() {
            const config = {
                startDate: document.getElementById('startDate').value,
                endDate: document.getElementById('endDate').value,
                maxIssues: document.getElementById('maxIssues').value
            };
            
            // Save to localStorage
            localStorage.setItem('jiraConfig', JSON.stringify(config));
            closeConfig();
            
            // Show loading message
            const errorDiv = document.getElementById('error-msg');
            errorDiv.style.display = 'block';
            errorDiv.style.background = '#d1ecf1';
            errorDiv.style.color = '#0c5460';
            errorDiv.textContent = `Running metrics collection for ${config.startDate} to ${config.endDate}...`;
            
            try {
                // Call the API to update .env and run collection
                const response = await fetch('/api/run-metrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) {
                    errorDiv.textContent = 'Collection complete! Refreshing dashboard...';
                    setTimeout(() => {
                        loadLatestMetrics();
                        errorDiv.style.display = 'none';
                    }, 1000);
                } else {
                    throw new Error('Failed to run metrics collection');
                }
            } catch (error) {
                errorDiv.style.background = '#f8d7da';
                errorDiv.style.color = '#721c24';
                errorDiv.textContent = 'Could not auto-run. Please run "npm start" in terminal with your chosen dates.';
            }
        }

        async function runMetrics() {
            const errorDiv = document.getElementById('error-msg');
            errorDiv.style.display = 'block';
            errorDiv.style.background = '#d1ecf1';
            errorDiv.style.color = '#0c5460';
            errorDiv.textContent = 'Running metrics collection with current .env settings...';
            
            try {
                const response = await fetch('/api/run-metrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                if (response.ok) {
                    errorDiv.textContent = 'Collection complete! Refreshing dashboard...';
                    setTimeout(() => {
                        loadLatestMetrics();
                        errorDiv.style.display = 'none';
                    }, 1000);
                } else {
                    throw new Error('Failed to run');
                }
            } catch (error) {
                errorDiv.style.background = '#fff3cd';
                errorDiv.style.color = '#856404';
                errorDiv.textContent = '‚ö†Ô∏è Auto-run not available. Please run "npm start" in your terminal.';
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('configModal');
            if (event.target === modal) {
                closeConfig();
            }
        }
    </script>
</body>
</html>
